<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders</title>
    <style>
        canvas { background: black; display: block; margin: 0 auto; }
        #gameOver { color: white; text-align: center; font-size: 2em; display: none; }
        .controls { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); }
        .control-button { background: rgba(255, 255, 255, 0.6); border: none; border-radius: 5px; padding: 10px; margin: 5px; font-size: 18px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="gameOver">Game Over</div>
    <div class="controls">
        <button id="leftButton" class="control-button">Left</button>
        <button id="rightButton" class="control-button">Right</button>
        <button id="shootButton" class="control-button">Shoot</button>
    </div>
    <script>


const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const playerWidth = 60, playerHeight = 40;
const bulletWidth = 5, bulletHeight = 10;
const shipWidth = 40, shipHeight = 30;
const shieldWidth = 80, shieldHeight = 40;
const monsterBulletWidth = 4, monsterBulletHeight = 8;
let player = { x: canvas.width / 2 - playerWidth / 2, y: canvas.height - playerHeight - 10, width: playerWidth, height: playerHeight };
let bullets = [];
let monsterBullets = [];
let enemies = [];
let shields = [];
let level = 0;
let score = 0;
let lives = 3;
let lastEnemyFireTime = 0;
let lifeLost = false;
const levels = [
    { enemyRows: 3, enemyColumns: 5, enemyTypes: 3, speed: 2, fireRate: 2000 },
    { enemyRows: 4, enemyColumns: 6, enemyTypes: 3, speed: 3, fireRate: 1500 },
    { enemyRows: 5, enemyColumns: 7, enemyTypes: 3, speed: 4, fireRate: 1000 }
];
let gameOver = false;
let moveDirection = 0; // 1 for right, -1 for left, 0 for stationary
let touchControls = { left: false, right: false, shoot: false };

// Initialization
function init() {
    setupLevel();
    document.addEventListener('keydown', handleKeydown);
    document.addEventListener('keyup', handleKeyup);
    document.getElementById('leftButton').addEventListener('touchstart', () => touchControls.left = true);
    document.getElementById('rightButton').addEventListener('touchstart', () => touchControls.right = true);
    document.getElementById('shootButton').addEventListener('touchstart', () => touchControls.shoot = true);
    document.getElementById('leftButton').addEventListener('touchend', () => touchControls.left = false);
    document.getElementById('rightButton').addEventListener('touchend', () => touchControls.right = false);
    document.getElementById('shootButton').addEventListener('touchend', () => touchControls.shoot = false);
    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchend', handleTouchEnd);
    gameLoop();
}

function setupLevel() {
    if (level < levels.length) {
        setupShields();
        setupEnemies();
    } else {
        gameOver = true;
        document.getElementById('gameOver').textContent = 'You Win!';
        document.getElementById('gameOver').style.display = 'block';
    }
}

function setupShields() {
    shields = [
        { x: 100, y: canvas.height - 150, width: shieldWidth, height: shieldHeight },
        { x: 300, y: canvas.height - 150, width: shieldWidth, height: shieldHeight },
        { x: 500, y: canvas.height - 150, width: shieldWidth, height: shieldHeight }
    ];
}

function setupEnemies() {
    enemies = [];
    const { enemyRows, enemyColumns, enemyTypes } = levels[level];
    for (let i = 0; i < enemyColumns; i++) {
        for (let j = 0; j < enemyRows; j++) {
            enemies.push({
                x: 100 + i * 60,
                y: 50 + j * 40,
                width: shipWidth,
                height: shipHeight,
                type: j % enemyTypes,
                score: j % enemyTypes === 0 ? 10 : (j % enemyTypes === 1 ? 20 : 30),
                canFire: Math.random() < 0.2, // Random chance to fire
                fireRate: Math.random() * 2000 + 1000 // Random firing rate
            });
        }
    }
}

function handleKeydown(e) {
    if (e.code === 'ArrowLeft') touchControls.left = true;
    if (e.code === 'ArrowRight') touchControls.right = true;
    if (e.code === 'Space') touchControls.shoot = true;
}

function handleKeyup(e) {
    if (e.code === 'ArrowLeft') touchControls.left = false;
    if (e.code === 'ArrowRight') touchControls.right = false;
    if (e.code === 'Space') touchControls.shoot = false;
}

function handleTouchStart(e) {
    const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
    if (touchX < canvas.width / 3) touchControls.left = true;
    else if (touchX > canvas.width * 2 / 3) touchControls.right = true;
    else touchControls.shoot = true;
}

function handleTouchEnd(e) {
    touchControls.left = false;
    touchControls.right = false;
    touchControls.shoot = false;
}

function movePlayer() {
    if (touchControls.right) {
        player.x += 5;
    }
    if (touchControls.left) {
        player.x -= 5;
    }
    if (touchControls.shoot) shoot();
    player.x = Math.min(Math.max(0, player.x), canvas.width - playerWidth);
}

function shoot() {
    if (Date.now() - lastFireTime > 200) { // Prevent rapid firing
        bullets.push({ x: player.x + playerWidth / 2 - bulletWidth / 2, y: player.y, width: bulletWidth, height: bulletHeight });
        lastFireTime = Date.now();
    }
}

function drawPlayer() {
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(player.x + playerWidth / 2, player.y);
    ctx.lineTo(player.x, player.y + playerHeight);
    ctx.lineTo(player.x + playerWidth / 2 - 10, player.y + playerHeight);
    ctx.lineTo(player.x + playerWidth / 2, player.y + playerHeight - 20);
    ctx.lineTo(player.x + playerWidth / 2 + 10, player.y + playerHeight);
    ctx.lineTo(player.x + playerWidth, player.y + playerHeight);
    ctx.closePath();
    ctx.fill();
}

function drawBullets() {
    ctx.fillStyle = 'red';
    bullets.forEach(bullet => ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height));
}

function drawMonsterBullets() {
    ctx.fillStyle = 'yellow';
    monsterBullets.forEach(bullet => ctx.fillRect(bullet.x, bullet.y, monsterBulletWidth, monsterBulletHeight));
}

function drawEnemies() {
    enemies.forEach(enemy => {
        ctx.fillStyle = enemy.type === 0 ? 'green' : (enemy.type === 1 ? 'purple' : 'blue');
        ctx.beginPath();
        switch (enemy.type) {
            case 0:
                ctx.moveTo(enemy.x, enemy.y + enemy.height);
                ctx.lineTo(enemy.x + enemy.width / 2, enemy.y);
                ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height);
                break;
            case 1:
                ctx.arc(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.width / 2, 0, Math.PI * 2);
                break;
            case 2:
                ctx.moveTo(enemy.x, enemy.y + enemy.height);
                ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height);
                ctx.lineTo(enemy.x + enemy.width / 2, enemy.y);
                break;
        }
        ctx.closePath();
        ctx.fill();
    });
}

function drawShields() {
    ctx.fillStyle = 'blue';
    shields.forEach(shield => {
        ctx.beginPath();
        ctx.arc(shield.x + shield.width / 2, shield.y + shield.height / 2, shield.width / 2, Math.PI, 0, false);
        ctx.lineTo(shield.x + shield.width, shield.y + shield.height);
        ctx.lineTo(shield.x, shield.y + shield.height);
        ctx.closePath();
        ctx.fill();
    });
}

function drawScore() {
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText('Score: ' + score, 10, 20);
    ctx.fillText('Lives: ' + lives, canvas.width - 100, 20);
    ctx.fillText('Level: ' + (level + 1), canvas.width / 2 - 30, 20);
}

function update() {
    if (gameOver) return;

    movePlayer();

    // Move player bullets
    bullets.forEach(bullet => bullet.y -= 5);

    // Remove off-screen bullets
    bullets = bullets.filter(bullet => bullet.y > 0);

    // Move monster bullets
    monsterBullets.forEach(bullet => bullet.y += 2);

    // Remove off-screen monster bullets
    monsterBullets = monsterBullets.filter(bullet => bullet.y < canvas.height);

    // Move enemies
    moveEnemies();

    // Check for collisions
    checkCollisions();

    // Check if player has lost a life
    if (lifeLost) {
        if (Date.now() - lifeLostStart > 1000) {
            lifeLost = false;
        } else {
            // Flash the screen or show an indicator
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    // Check for game over
    if (lives <= 0) {
        gameOver = true;
        document.getElementById('gameOver').textContent = 'Game Over!';
        document.getElementById('gameOver').style.display = 'block';
    }
}

function moveEnemies() {
    const { speed } = levels[level];
    let hitEdge = false;

    // Move enemies horizontally based on direction
    enemies.forEach(enemy => {
        enemy.x += speed * moveDirection;
        if (enemy.x < 0 || enemy.x + enemy.width > canvas.width) {
            hitEdge = true;
        }
    });

    if (hitEdge) {
        enemies.forEach(enemy => enemy.y += 10);
        moveDirection *= -1;
    }

    // Monster firing
    if (Date.now() - lastEnemyFireTime > levels[level].fireRate) {
        enemies.forEach(enemy => {
            if (enemy.canFire && Math.random() < 0.1) { // Random chance to fire
                monsterBullets.push({
                    x: enemy.x + enemy.width / 2 - monsterBulletWidth / 2,
                    y: enemy.y + enemy.height,
                    width: monsterBulletWidth,
                    height: monsterBulletHeight
                });
            }
        });
        lastEnemyFireTime = Date.now();
    }

    // Check if all enemies are destroyed
    if (enemies.length === 0) {
        level++;
        setupLevel();
    }
}

function checkCollisions() {
    bullets.forEach(bullet => {
        enemies.forEach((enemy, index) => {
            if (bullet.x < enemy.x + enemy.width &&
                bullet.x + bullet.width > enemy.x &&
                bullet.y < enemy.y + enemy.height &&
                bullet.y + bullet.height > enemy.y) {
                score += enemy.score;
                enemies.splice(index, 1);
                bullets = bullets.filter(b => b !== bullet);
            }
        });
    });

    monsterBullets.forEach(bullet => {
        if (bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y) {
            lives--;
            lifeLost = true;
            lifeLostStart = Date.now();
            monsterBullets = monsterBullets.filter(b => b !== bullet);
        }
    });

    // Check shield collisions
    bullets.forEach(bullet => {
        shields.forEach(shield => {
            if (bullet.x < shield.x + shield.width &&
                bullet.x + bullet.width > shield.x &&
                bullet.y < shield.y + shield.height &&
                bullet.y + bullet.height > shield.y) {
                shield.width -= 10; // Increased reduction for better visibility
                shield.height -= 5; // Increased reduction for better visibility
                bullets = bullets.filter(b => b !== bullet);
                if (shield.width <= 0 || shield.height <= 0) {
                    shields = shields.filter(s => s !== shield);
                }
            }
        });
    });

    // Check collisions with shields
    monsterBullets.forEach(bullet => {
        shields.forEach(shield => {
            if (bullet.x < shield.x + shield.width &&
                bullet.x + bullet.width > shield.x &&
                bullet.y < shield.y + shield.height &&
                bullet.y + bullet.height > shield.y) {
                shield.width -= 10; // Increased reduction for better visibility
                shield.height -= 5; // Increased reduction for better visibility
                monsterBullets = monsterBullets.filter(b => b !== bullet);
                if (shield.width <= 0 || shield.height <= 0) {
                    shields = shields.filter(s => s !== shield);
                }
            }
        });
    });

    // Check collisions with player base
    enemies.forEach((enemy, index) => {
        if (enemy.y + enemy.height > canvas.height - playerHeight) {
            lives--;
            lifeLost = true;
            lifeLostStart = Date.now();
            enemies.splice(index, 1);
            if (lives <= 0) gameOver = true;
        }
    });
}

function gameLoop() {
    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPlayer();
    drawBullets();
    drawMonsterBullets();
    drawEnemies();
    drawShields();
    drawScore();
    update();
    requestAnimationFrame(gameLoop);
}

init();


        
    </script>
</body>
</html>
