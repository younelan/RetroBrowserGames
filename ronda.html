<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ronda Game</title>
<style>
body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    color: #333;
    text-align: center;
}
.hand, .table-cards {
    margin: 10px 0;
}
.card {
    display: inline-block;
    padding: 10px;
    margin: 5px;
    border: 1px solid #000;
    border-radius: 5px;
    min-width: 6em;
    background-color: #fff;
    color: #000; /* Dark text */
    cursor: pointer;
}
.card:hover {
    background-color: #f9f9f9;
}
.card.clubs, .card.shbada { background-color: #b6d5fd; }
.card.coins, .card.dehb { background-color: #f7d794; }
.card.swords, .card.khel { background-color: #cef8e0 }
.card.cups, .card.guebbas { background-color: #f894b7;}
#table {
    border: 2px solid #000;
    padding: 20px;
    background-color: #fff;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    justify-content: center;
}
#history {
    margin-top: 20px;
    text-align: left;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}
#handContainer {
    display:none;
}
#deal-button {
    display:none;
}
</style>
</head>
<body>
<h1>Ronda Game</h1>
<button id="deal-button">Deal Cards</button>
<div id="table" class="table-cards"></div>
<div id="humanContainer">
    <h2>Human Player's Hand</h2>
    <div id="human-hand" class="hand"></div>
</div>
<div id="handContainer">
    <h2>Computer Player's Hand</h2>
    <div id="computer-hand" class="hand"></div>
</div>
<div id="score"></div>
<div id="history"></div>

</body>
</html>


<script>
cardDetails = {
  1: { short: '0', name: 'As' },
  2: { short: '1', name: 'Dos' },
  3: { short: '2', name: 'Tres' },
  4: { short: '3', name: 'Quatro' },
  5: { short: '4', name: 'Cinco' },
  6: { short: '5', name: 'Sies' },
  7: { short: '6', name: 'Siete' },
  10: { short: '7', name: 'Sauta' },
  11: { short: '8', name: 'Cabal' },
  12: { short: '9', name: 'Rey' }
};
class Deck {
    constructor() {
        this.suits = ['Dehb', 'Guebbas', 'Khel', 'Shbada'];
        this.values = [1, 2, 3, 4, 5, 6, 7, 10, 11, 12];
        this.cards = [];

        // Initialize the deck
        for (let suit of this.suits) {
            for (let value of this.values) {
                this.cards.push({ value, suit });
            }
        }
    }

    shuffle() {
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }

    deal(numPlayers, numCards) {
        const hands = [];
        for (let i = 0; i < numPlayers; i++) {
            hands.push([]);
        }

        for (let i = 0; i < numCards; i++) {
            for (let j = 0; j < numPlayers; j++) {
                hands[j].push(this.cards.pop());
            }
        }

        return hands;
    }
    detectRondasAndTringas(hand) {
        const cardCount = {};
        hand.forEach(card => {
            cardCount[card.value] = (cardCount[card.value] || 0) + 1;
        });

        const rondas = [];
        const tringas = [];

        for (let value in cardCount) {
            if (cardCount[value] === 3) {
                tringas.push(value);
            } else if (cardCount[value] === 2) {
                rondas.push(value);
            }
        }

        return { rondas, tringas };
    }
}

class Player {
    constructor() {
        this.hand = [];
        this.score = 0;
        this.pile = [];
    }

    receiveCard(card) {
        this.hand.push(card);
    }

    showHand() {
        return this.hand.map(card => `${card.value} <br/><br/> ${card.suit}`).sort((a, b) => {
            const valueA = parseInt(a.split(' ')[0]);
            const valueB = parseInt(b.split(' ')[0]);
            return valueA - valueB;
        }).join(', ');
    }

    playCard(index) {
        return this.hand.splice(index, 1)[0];
    }

    addScore(points) {
        this.score += points;
    }
    addToPile(cards) {
        this.pile.push(...cards);
    }
    detectRondasAndTringas() {
        return deck.detectRondasAndTringas(this.hand);
    }
}

function displayHand(player, elementId) {
    const handElement = document.getElementById(elementId);
    handElement.innerHTML = '';
    player.hand.sort((a, b) => a.value - b.value).forEach((card, index) => {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${getCardClass(card.suit)}`;
        cardElement.innerHTML = `${card.value} <br/><br/> ${card.suit}`;
        cardElement.addEventListener('click', () => playTurn(player, index));
        handElement.appendChild(cardElement);
    });
}

function displayTable(cards) {
    const tableElement = document.getElementById('table');
    tableElement.innerHTML = '';
    cards.sort((a, b) => a.value - b.value).forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${getCardClass(card.suit)}`;
        cardElement.innerHTML = `${card.value} <br/><br/> ${card.suit}`;
        tableElement.appendChild(cardElement);
    });
}

function updateScore(humanPlayer, computerPlayer) {
    const scoreElement = document.getElementById('score');
    scoreElement.textContent = `Human: ${humanPlayer.score} - Computer: ${computerPlayer.score}`;
}

let historyCounter = 1;

function logHistory(message) {
    const historyElement = document.getElementById('history');
    const logEntry = document.createElement('div');
    logEntry.textContent = `${historyCounter++}. ${message}`;
    historyElement.prepend(logEntry); // Add new log entry at the top
}



function playTurn(player, cardIndex) {
    const card = player.playCard(cardIndex);
    const previousCard = tableCards.length > 0 ? tableCards[tableCards.length - 1] : null;
    const eatenCards = eatCards(card);
    const pointsEarned = calculatePoints(card, eatenCards);
    player.addToPile([card, ...eatenCards]);

    if (eatenCards.length > 0) {
        player.addScore(pointsEarned);
        logHistory(`Human played ${card.value} of ${card.suit} and ate ${eatenCards.length} cards: ${eatenCards.map(c => `${c.value} of ${c.suit}`).join(', ')}, earning ${pointsEarned} points`);
        if (tableCards.length === 0) {
            player.addScore(1); // Missa point
            logHistory('Human did Missa!');
        }
    } else {
        tableCards.push(card);
        //logHistory(`Human played ${card.value} of ${card.suit} but ate no cards`);
    }

    displayHand(humanPlayer, 'human-hand');
    displayTable(tableCards);

    // Check for bwa7ed
    if (previousCard && previousCard.value === card.value && !isDifferentTurn) {
        player.addScore(1);
        logHistory('Human did bwa7ed!');
    }

    // Computer's turn
    setTimeout(() => {
        const computerCard = computerPlayer.playCard(0);
        const previousCard = tableCards.length > 0 ? tableCards[tableCards.length - 1] : null;
        const computerEatenCards = eatCards(computerCard);
        const computerPointsEarned = calculatePoints(computerCard, computerEatenCards);
        computerPlayer.addToPile([computerCard, ...computerEatenCards]);

        if (computerEatenCards.length > 0) {
            computerPlayer.addScore(computerPointsEarned);
            logHistory(`Computer played ${computerCard.value} of ${computerCard.suit} and ate ${computerEatenCards.length} cards: ${computerEatenCards.map(c => `${c.value} of ${c.suit}`).join(', ')}, earning ${computerPointsEarned} points`);
            if (tableCards.length === 0) {
                computerPlayer.addScore(1); // Missa point
                logHistory('Computer did Missa!');
            }
        } else {
            tableCards.push(computerCard);
            logHistory(`Computer played ${computerCard.value} of ${computerCard.suit} but ate no cards`);
        }

        displayHand(computerPlayer, 'computer-hand');
        displayTable(tableCards);

        // Check for bwa7ed
        if (previousCard && previousCard.value === computerCard.value && !isDifferentTurn) {
            computerPlayer.addScore(1);
            logHistory('Computer did bwa7ed!');
        }

        // Check if the deck is empty and deal new cards if necessary
        if (humanPlayer.hand.length === 0 && computerPlayer.hand.length === 0 && deck.cards.length > 0) {
            const hands = deck.deal(2, 4);
            hands[0].forEach(card => humanPlayer.receiveCard(card));
            hands[1].forEach(card => computerPlayer.receiveCard(card));
            determineWinnerAndAwardPoints([humanPlayer, computerPlayer]);
            displayHand(humanPlayer, 'human-hand');
            displayHand(computerPlayer, 'computer-hand');
            isDifferentTurn = true;
        } else if (humanPlayer.hand.length === 0 && computerPlayer.hand.length === 0 ) {
            isGameOver = true
            if(humanPlayer.score>computerPlayer.score) {
                logHistory(`Human Won`);

            } else if(humanPlayer.score<computerPlayer.score) {
                logHistory(`Computer Won`);

            } else {
                logHistory(`Equal Score`);

            }
            logHistory(`Computer played ${computerCard.value} of ${computerCard.suit} but ate no cards`);

        } else {
            isDifferentTurn = false;
        }

        // Update score
        updateScore(humanPlayer, computerPlayer);
    }, 1000); // Adding delay to simulate computer thinking time
}


function eatCards(card) {
    const eatenCards = [];
    const tableCardValues = tableCards.map(c => c.value);
    let valueToCheck = card.value;

    // Check if the card can eat other cards on the table
    while (tableCardValues.includes(valueToCheck)) {
        const cardIndex = tableCardValues.indexOf(valueToCheck);
        if (cardIndex !== -1) {
            eatenCards.push(tableCards.splice(cardIndex, 1)[0]);
            tableCardValues.splice(cardIndex, 1); // Remove the eaten card value from the list
            valueToCheck++;
            if (valueToCheck==8) {
                valueToCheck=10;
            }
        } else {
            break;
        }
    }

    // Add the played card to the eaten pile if any cards were eaten
    if (eatenCards.length > 0) {
        eatenCards.unshift(card); // Add the played card to the pile
    }

    return eatenCards;
}


function calculatePoints(card, eatenCards) {
    let points = 0;

    if (eatenCards.length > 0) {
        // Points for each card eaten
        points += eatenCards.length; // 1 point per card

        // Points for the card played
        points += 1;

        // Check for bwa7ed (same card played immediately before)
        if (tableCards.length > 0 && tableCards[tableCards.length - 1].value === card.value) {
            points += 1;
        }

        // Check for missa
        if (tableCards.length === 0) {
            points += 1;
        }
    }

    return points;
}

function getCardClass(suit) {
    switch (suit) {
        case 'Guebbas': return 'cups';
        case 'Khel': return 'clubs';
        case 'Shbada': return 'swords';
        case 'Dehb': return 'coins';
        case 'Clubs': return 'clubs';
        case 'Coins': return 'coins';
        case 'Swords': return 'swords';
        case 'Cups': return 'cups';
        default: return '';
    }
}

const deck = new Deck();
deck.shuffle();

const humanPlayer = new Player();
const computerPlayer = new Player();
const tableCards = [];
let isDifferentTurn = false;

function determineWinnerAndAwardPoints() {
    const humanResults = deck.detectRondasAndTringas(humanPlayer.hand);
    const computerResults = deck.detectRondasAndTringas(computerPlayer.hand);

    const humanTringas = humanResults.tringas;
    const humanRondas = humanResults.rondas;
    const computerTringas = computerResults.tringas;
    const computerRondas = computerResults.rondas;

    // Determine the highest tringa value and ronda value for each player
    const humanMaxTringa = humanTringas.length > 0 ? Math.max(...humanTringas) : 0;
    const computerMaxTringa = computerTringas.length > 0 ? Math.max(...computerTringas) : 0;

    const humanMaxRonda = humanRondas.length > 0 ? Math.max(...humanRondas) : 0;
    const computerMaxRonda = computerRondas.length > 0 ? Math.max(...computerRondas) : 0;

    // Calculate total points
    const humanTotalPoints = (humanTringas.length > 0 ? 5 *humanTringas.length : 0) +
                             (humanRondas.length > 0 ? humanRondas.length : 0);

    const computerTotalPoints = (computerTringas.length > 0 ? 5 * computerTringas.length : 0) +
                                (computerRondas.length > 0 ? computerRondas.length : 0);
    const combinedTotalPoints = humanTotalPoints+computerTotalPoints
    // Determine the winner and award points
    if (humanMaxTringa > computerMaxTringa) {
        // Human has the highest tringa
        humanPlayer.addScore(combinedTotalPoints);
        logHistory(`Human wins Tringa with ${combinedTotalPoints} points`);
    } else if (computerMaxTringa > humanMaxTringa) {
        // Computer has the highest tringa
        computerPlayer.addScore(combinedTotalPoints);
        logHistory(`Computer wins Tringa with ${combinedTotalPoints} points`);
    } else {
        // No tringa or both have the same tringa
        if (humanMaxRonda > computerMaxRonda) {
            // Human has the highest ronda
            humanPlayer.addScore(combinedTotalPoints);
            logHistory(`Human wins with ${combinedTotalPoints} points (Ronda: ${humanMaxRonda})`);
        } else if (computerMaxRonda > humanMaxRonda) {
            // Computer has the highest ronda
            computerPlayer.addScore(combinedTotalPoints);
            logHistory(`Computer wins with ${combinedTotalPoints} points (Ronda)`);
        } else {
            // Both players have the same ronda or no tringa
            if (humanTotalPoints > computerTotalPoints) {
                humanPlayer.addScore(combinedTotalPoints);
                logHistory(`Human wins Ronda with ${combinedTotalPoints} points`);
            } else if (computerTotalPoints > humanTotalPoints) {
                computerPlayer.addScore(combinedTotalPoints);
                logHistory(`Computer wins Ronda with ${combinedTotalPoints} points`);
            } else {
                // Both players have equal points
                //logHistory('It\'s a tie with equal points for both players');
            }
        }
    }
}

function startGame() {
    const hands = deck.deal(2, 4);
    hands[0].forEach(card => humanPlayer.receiveCard(card));
    hands[1].forEach(card => computerPlayer.receiveCard(card));

    
    displayHand(humanPlayer, 'human-hand');
    displayHand(computerPlayer, 'computer-hand');
    determineWinnerAndAwardPoints([humanPlayer, computerPlayer]);

    displayTable(tableCards);
    updateScore(humanPlayer, computerPlayer);

}

document.getElementById('deal-button').addEventListener('click', () => {
startGame();
});

startGame();
    
</script>